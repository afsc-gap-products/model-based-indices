---
title: "sdmTMB Bering indices"
output:
  bookdown::pdf_document2:
    highlight: pygments
    toc: true
    number_sections: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.asp = 0.618,
  cache = FALSE,
  autodep = TRUE,
  cache.comments = FALSE
)
```

```{r packages, message=FALSE, warning=FALSE, cache=FALSE}
#remotes::install_github("pbs-assess/sdmTMB")
#remotes::install_github("pbs-assess/sdmTMB@index-split")
remotes::install_github("afsc-gap-products/coldpool")
library(sdmTMB)
library(dplyr)
library(ggplot2)
library(here)

phase <- c("hindcast", "production")[1] # specify analysis phase
species <- "yellowfin_sole" 
#pollock pacific_cod yellowfin_sole kamchatka_flounder
```

We will fit geostatistical spatiotemporal models with sdmTMB for the purposes of index standardization. We will use data from the EBS/NBS AFSC GAP bottom trawl surveys. The density units we will work in are either kg/km^2^ or n/km^2^, for biomass or numerical abundance. 

```{r data, echo = TRUE}
if(species == "pacific_cod"){
  dat <- readRDS(here("species_specific_code", "BS", species, phase, 
                        "data", "data_geostat_index.RDS"))
  dat <-  rename(dat, cpue = cpue_n_km2)
}
if(species == "pollock"){
  dat <- read.csv(here("species_specific_code", "BS", species, "VAST_ddc_all_2023.csv"))  
  dat <-  dplyr::transmute(dat,
                         cpue = ddc_cpue_kg_ha * 100, # converts cpue from kg/ha to kg/km^2
                         year = as.integer(year),
                         lat = start_latitude,
                         lon = start_longitude
                         )
}
if(species %in% c("yellowfin_sole", "kamchatka_flounder")){
  dat <- readRDS(here("species_specific_code", "BS", species, phase, 
                       "data", "data_geostat_index.RDS"))  
  dat <-  rename(dat, cpue = cpue_kg_km2)
}
```

We also need to pull in the appropriate environmental covariate as this is used as a spatially varying covariate in AFSC GAP Bering Sea indices. For yellowfin sole, this is the mean bottom temperature in waters less than 100m. For other species, this is the cold pool extent. The cold pool is defined here as the areal extent (in km^2^) of seawater equal to or colder than 2 degrees Celsius near the seafloor, calculated from observations from the AFSC GAP EBS/NBS bottom trawl survey. We center and scale this for inclusion as a covariate.

```{r covariate, echo = TRUE}

env_df <- coldpool:::cold_pool_index
  
if(species == "yellowfin_sole"){
  env <- cbind(env_df, env = scale(coldpool:::cold_pool_index$MEAN_BT_LT100M)) |>
    mutate(year = as.integer(YEAR)) |>
    select(year, env)
} else {
  env <- cbind(env_df, env = scale(coldpool:::cold_pool_index$AREA_LTE2_KM2)) |>
    mutate(year = as.integer(YEAR)) |>
    select(year, env)
}

dat <- left_join(dat, env, by = "year") 
```
Now we fit the model in sdmTMB:

```{r fit, echo = TRUE}
dat$year_f <- as.factor(dat$year)

add_utm_columns(dat, ll_names = c("lon", "lat"), utm_crs = 32602, units = "km")

# detect if any years have occurrences at every haul and fix params as needed
mins <- dat %>% group_by(year) %>% summarize(min = min(cpue))
if(sum(mins$min) == 0){
  control = sdmTMBcontrol()
} else {
  no_zero_yr <- as.integer(mins %>% filter(min > 0) %>% select(year))
			# set up map and fix value of p(occurrence) to slightly less than 1:
			yrs <- unique(dat$year)
			.map <- seq_along(yrs)
			.map[yrs %in% no_zero_yr] <- NA
			.map <- factor(.map)
			.start <- rep(0, length(yrs))
			.start[yrs %in% no_zero_yr] <- 20

			control =  sdmTMBcontrol(
			      map = list(b_j = .map),
			      start = list(b_j = .start)
			    )
}

f1 <- here("species_specific_code", "BS", species, "index_comparison", "fit.RDS")
if (!file.exists(f1)) {
  
    if(species == "kamchatka_flounder"){
      #make mesh just for EBS only
      mesh <-  make_mesh(dat, xy_cols = c("X", "Y"), 
                         n_knots = 250, type = "kmeans")
      #fit to EBS only, using IID spatiotemporal fields instead of "ar1"
      fit <- sdmTMB( 
        cpue ~ 0 + year_f,
        spatial_varying = ~ env,
        data = dat, 
        mesh = mesh,
        family = delta_gamma(type = "poisson-link"), 
        time = "year", 
        spatial = "on",
        spatiotemporal = "iid",
        silent = FALSE,
        anisotropy = TRUE,
        control = control
      )
    } else {
        #pass same mesh as prior model
        mesh <-  make_mesh(dat, xy_cols = c("X", "Y"), 
                     mesh = readRDS(file = here("meshes/bs_vast_mesh.RDS")))
        fit <- sdmTMB( 
          cpue ~ 0 + year_f,
          spatial_varying = ~ env,
          data = dat, 
          mesh = mesh,
          family = delta_gamma(type = "poisson-link"), 
          time = "year", 
          spatial = "on",
          spatiotemporal = "ar1",
          extra_time = 2020L, 
          silent = FALSE,
          anisotropy = TRUE,
          control = control
        )
    }
    saveRDS(fit, file = here("species_specific_code", "BS", species, "index_comparison", "fit.RDS"))
  } else {
    fit <- readRDS(f1)
}

sanity(fit)
summary(fit)
# diagnose estimation issues due to model structure
#TMBhelper::check_estimability(fit$tmb_obj)
```

Make predictions and index:

```{r predictions-index, echo=TRUE}
# EBS grid
grid_ebs <- read.csv(here("extrapolation_grids", "nbs_coarse_grid.csv"))

# NBS grid
grid_nbs <- read.csv(here("extrapolation_grids", "nbs_coarse_grid.csv"))

# Combined grid
grid <- read.csv(here("extrapolation_grids", "bering_coarse_grid.csv"))

# replicate prediction grids for each year in data
pred_grid_ebs <- replicate_df(grid_ebs, "year_f", unique(dat$year_f))
pred_grid_nbs <- replicate_df(grid_nbs, "year_f", unique(dat$year_f))
pred_grid <- replicate_df(grid, "year_f", unique(dat$year_f))
pred_grid_ebs$year <- as.integer(as.character(factor(pred_grid_ebs$year_f)))
pred_grid_nbs$year <- as.integer(as.character(factor(pred_grid_nbs$year_f)))
pred_grid$year <- as.integer(as.character(factor(pred_grid$year_f)))

# join in environmental covariate (cold pool or mean bottom temperature)
pred_grid_ebs <- left_join(pred_grid_ebs, env, by = "year") 
pred_grid_nbs <- left_join(pred_grid_nbs, env, by = "year")
pred_grid <- left_join(pred_grid, env, by = "year")

# get predictions
f2 <- here("species_specific_code", "BS", species,
           "index_comparison", "predictions.RDS")
if (!file.exists(f2)) {
  gc()
  if(species == "kamchatka_flounder"){
    p <- predict(fit, newdata = pred_grid_ebs, return_tmb_object = TRUE)
  } else {
      p <- predict(fit, newdata = pred_grid, return_tmb_object = TRUE)
  }
  saveRDS(p, file = f2)
  # p_ebs <- predict(fit, newdata = pred_grid_ebs, return_tmb_object = TRUE)
  # p_nbs <- predict(fit, newdata = pred_grid_nbs, return_tmb_object = TRUE)
  # save(p, p_ebs, p_nbs, file = f2)
} else {
  load(f2)
}

# get indices
f3 <- here("species_specific_code", "BS", species,
           "index_comparison", "index.RDS")
if (!file.exists(f3)) {
  gc()
  if(species == "kamchatka_flounder"){
    ind <- get_index(p, bias_correct = TRUE, area = pred_grid$area_km2)
    ind$stratum <- "Both"
  } else {
    ind <- get_index(p, bias_correct = TRUE, area = pred_grid_ebs$area_km2)
    ind$stratum <- "EBS"
  }
  saveRDS(ind, file = f3)
  # ind <- get_index(p, bias_correct = TRUE, area = pred_grid$area_km2)
  # ind$stratum <- "Both"
  # 
  # ind_ebs <- get_index(p_ebs, bias_correct = TRUE, area = pred_grid_ebs$area_km2)
  # ind_ebs$stratum <- "EBS"
  # 
  # ind_nbs <- get_index(p_nbs, bias_correct = TRUE, area = pred_grid_nbs$area_km2)
  # ind_nbs$stratum <- "NBS"
  # save(ind, ind_ebs, ind_nbs, file = f3)
} else {
load(f3)
}

# NOTE: if using get_index_split() rather than get_index() you need to pass the 
# model object and new data (not prediction object, you can bypass that step) and run:
# f3 <- here("species_specific_code", "BS", species, phase, "index.RDS")
# if (!file.exists(f3)) {
#   gc()
#   if(species == "kamchatka_flounder"){
#     ind <- get_index_split(fit, newdata = pred_grid_ebs, nsplit = 2,
#                            bias_correct = TRUE, 
#                            area = pred_grid_ebs$area_km2)
#   } else {
#       ind <- get_index_split(fit, newdata = pred_grid, nsplit = 2, # may need 6 if have 64GB RAM
#                              bias_correct = TRUE, 
#                              area = pred_grid$area_km2)
#   }
#   saveRDS(ind, file = here("species_specific_code", "BS", species, phase, "index.RDS"))
# } else {
# load(f3)
# }
```
Make maps and diagnostics:

```{r plots, echo=TRUE}
## Plot predicted density maps and fit diagnostics ----
# q-q plot
pdf(file = here("species_specific_code", "BS", species, phase, "qq.pdf"), 
    width = 5, height = 5)
  simulate(fit, nsim = 500, type = "mle-mvn") |>
    dharma_residuals(fit, test_uniformity = FALSE)
dev.off()

# residuals on map plot, by year
dat$resids <- residuals(fit, type ="mle-mvn") 
ggplot(subset(dat, !is.na(resids)), aes(X, Y, col = resids)) + 
  scale_colour_gradient2(name = "residuals") +
  geom_point(size = 0.7) + 
  facet_wrap(~year) + 
  coord_fixed() +
  theme_bw()
ggsave(file = here("species_specific_code", "BS", species, phase, 
                   "residuals_map.pdf"), 
       height = 9, width = 6.5, units = c("in"))

# predictions on map plot, by year
if(species == "Gadus_macrocephalus"){
  title <- "Predicted densities (n / square km)"
} else {
  title <- "Predicted densities (kg / square km)"
}
ggplot(p$data, aes(X, Y, fill = exp(est1 + est2))) +
  geom_tile() +
  scale_fill_viridis_c(trans = "sqrt", name = "") +
  facet_wrap(~year, ncol = 2) +
  coord_fixed() +
  ggtitle(title) +
  theme_bw()
ggsave(file = here("species_specific_code", "BS", species, phase,
                   "predictions_map.pdf"),
       height = 9, width = 6.5, units = c("in"))
```

Now, we can compare the index to the prior model after making sure you're connected to Oracle db.

```{r index-compare, message=FALSE, warning=FALSE}
# Plot design-based estimate vs old and new model estimate ---------------------
# query db index
channel <- gapindex::get_connected(check_access = FALSE) # enter credentials 

if(species == "kamchatka_flounder"){
    stratum <- "EBS"
  } else {
    stratum <- "Both"
  }

if(species == "Gadus_macrocephalus"){
  query <- paste0('
    SELECT 
    \'db\' AS "index",
    YEAR AS "year",
    POPULATION_COUNT AS "est",
    (POPULATION_COUNT - SQRT(POPULATION_VAR) * (1.959964)) as "lwr", -- qnorm(0.025) in R
    (POPULATION_COUNT + SQRT(POPULATION_VAR) * (1.959964)) as "upr" -- qnorm(0.975) in R
    
    -- Identify what tables to pull data from
    WHERE SURVEY_DEFINITION_ID IN (143, 98)
    AND SPECIES_CODE = ', unique(dat$species_code)
  )
} else {
  query <- paste0('
    SELECT 
    \'db\' AS "index",
    YEAR AS "year",
    BIOMASS_MT * 1000 AS "est",
    (BIOMASS_MT - SQRT(BIOMASS_VAR) * (1.959964)) * 1000 as "lwr", -- qnorm(0.025) in R
    (BIOMASS_MT + SQRT(BIOMASS_VAR) * (1.959964)) * 1000 as "upr" -- qnorm(0.975) in R
    
    -- Identify what tables to pull data from
    WHERE SURVEY_DEFINITION_ID IN (143, 98)
    AND SPECIES_CODE = ', unique(dat$species_code)
  )
}
db_i <- RODBC::sqlQuery(channel = channel, query = query)

new_i <- ind %>% mutate(index = "mb_new") %>% select(index, year, est, lwr, upr)

old_i <- read.csv(here("species_specific_code", "BS", species, "index_comparison", "Index.csv")) %>%
#old_i <- read.csv(here("species_specific_code", "BS", species, phase, "Index.csv")) %>%
  mutate(index = "mb_old", year = as.numeric(Time), est = Estimate, 
    se = Std..Error.for.ln.Estimate.) %>% 
  filter(year %in% unique(new_i$year), Stratum == stratum) %>%
  select(index, year, est, se) %>% 
  mutate(lwr = exp(log(est) + qnorm(0.025) * se),
         upr = exp(log(est) + qnorm(0.975) * se)) %>%
  select(index, year, est, lwr, upr)

both_i <- bind_rows(new_i, old_i, db_i) %>% 
  filter(est > 0)
both_i[both_i < 0] <- 0

# plot  
if(species == "Gadus_macrocephalus"){
  ylab <- "Abundance (n)"
} else {
  ylab <- "Biomass (kg)"
}
ggplot(both_i, aes(x = year, y = est, ymin = lwr, ymax = upr, 
                   colour = index)) + 
  geom_ribbon(alpha = 0.1) +
  geom_line(alpha = 0.8) + 
  ylim(0, max(both_i$upr)) +
  ggtitle(species) +
  coord_cartesian(expand = FALSE) + 
  ylab(ylab) +
  theme_bw()
ggsave(file = here("species_specific_code", "BS", species, phase, 
                   "index_comparison.pdf"), 
       height = 4, width = 6, units = c("in"))

#### ESP products ----
# TODO: check if there is different trend without bias correction
f4 <- here("species_specific_code", "BS", species, phase, "cog.RDS")
if (!file.exists(f4)) {
  cog <- get_cog(p, bias_correct = FALSE, 
                 area = p$data$area_km2, format = "wide")
  saveRDS(cog, file = here("species_specific_code", "BS", 
                           species, phase, "cog.RDS"))
}

f5 <- here("species_specific_code", "BS", species, phase, 
           "area_occupied.RDS")
if (!file.exists(f5)) {
eao <- get_eao(p, bias_correct = FALSE, area = p$data$area_km2)
saveRDS(eao, file = here("species_specific_code", "BS", 
                         species, phase, "area_occupied.RDS"))
}
```
