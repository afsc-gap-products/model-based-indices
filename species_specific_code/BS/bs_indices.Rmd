---
title: "sdmTMB Bering indices"
output:
  bookdown::pdf_document2:
    highlight: pygments
    toc: true
    number_sections: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.asp = 0.618,
  cache = FALSE,
  autodep = TRUE,
  cache.comments = FALSE
)
```

```{r packages, message=FALSE, warning=FALSE, cache=FALSE}
#pak::pak("pbs-assess/sdmTMB")
#pak::pak("pbs-assess/sdmTMB@index-split")
#pak::pak("afsc-gap-products/coldpool")
library(sdmTMB)
library(dplyr)
library(ggplot2)
library(here)

phase <- c("hindcast", "production")[1] # specify analysis phase
species <- "yellowfin_sole" 
#pollock pacific_cod yellowfin_sole kamchatka_flounder
```

We will fit geostatistical spatiotemporal models with sdmTMB for the purposes of index standardization. We will use data from the EBS/NBS AFSC GAP bottom trawl surveys. The density units we will work in are either kg/km^2^ or n/km^2^, for biomass or numerical abundance. 

```{r data, echo = TRUE}
if(species == "pacific_cod"){
  dat <- readRDS(here("species_specific_code", "BS", species, phase, 
                        "data", "data_geostat_index.RDS"))
  dat <-  rename(dat, cpue = cpue_n_km2)
}
if(species == "pollock"){
  dat <- read.csv(here("species_specific_code", "BS", species, "VAST_ddc_all_2023.csv"))  
  dat <-  dplyr::transmute(dat,
                         cpue = ddc_cpue_kg_ha * 100, # converts cpue from kg/ha to kg/km^2
                         year = as.integer(year),
                         lat = start_latitude,
                         lon = start_longitude
                         )
}
if(species %in% c("yellowfin_sole", "kamchatka_flounder")){
  dat <- readRDS(here("species_specific_code", "BS", species, phase, 
                       "data", "data_geostat_index.RDS"))  
  dat <-  rename(dat, cpue = cpue_kg_km2)
}
```

We also need to pull in the appropriate environmental covariate as this is used as a spatially varying covariate in AFSC GAP Bering Sea indices. For yellowfin sole, this is the mean bottom temperature in waters less than 100m. For other species, this is the cold pool extent. The cold pool is defined here as the areal extent (in km^2^) of seawater equal to or colder than 2 degrees Celsius near the seafloor, calculated from observations from the AFSC GAP EBS/NBS bottom trawl survey. We center and scale this for inclusion as a covariate.

```{r covariate, echo = TRUE}
if(species == "yellowfin_sole"){
  env <- scale(coldpool:::cold_pool_index$MEAN_BT_LT100M)
} else {
  env <- scale(coldpool:::cold_pool_index$AREA_LTE2_KM2)
}

dat <- left_join(dat, env, by = "year") 
```
Now we fit the model in sdmTMB:

```{r sdmTMB-example, echo = TRUE}
dat$year_f <- as.factor(dat$year)

add_utm_columns(dat, ll_names = c("lon", "lat"), units = "km")

# detect if any years have occurrences at every haul and fix params as needed
mins <- dat %>% group_by(year) %>% summarize(min = min(cpue))
if(sum(mins$min) == 0){
  control = sdmTMBcontrol()
} else {
  no_zero_yr <- as.integer(mins %>% filter(min > 0) %>% select(year))
			# set up map and fix value of p(occurrence) to slightly less than 1:
			yrs <- unique(dat$year)
			.map <- seq_along(yrs)
			.map[yrs %in% no_zero_yr] <- NA
			.map <- factor(.map)
			.start <- rep(0, length(yrs))
			.start[yrs %in% no_zero_yr] <- 20

			control =  sdmTMBcontrol(
			      map = list(b_j = .map),
			      start = list(b_j = .start)
			    )
}

f1 <- here("species_specific_code", "BS", species, "index_comparison", "fit.RDS")
if (!file.exists(f1)) {
  
    if(species == "kamchatka_flounder"){
      #make mesh just for EBS only
      mesh <-  make_mesh(dat, xy_cols = c("X", "Y"), 
                         n_knots = 250, type = "kmeans")
      #fit to EBS only, using IID spatiotemporal fields instead of "ar1"
      fit <- sdmTMB( 
        cpue ~ 0 + year_f,
        spatial_varying = ~ env,
        data = dat, 
        mesh = mesh,
        family = delta_gamma(type = "poisson-link"), 
        time = "year", 
        spatial = "on",
        spatiotemporal = "iid",
        silent = FALSE,
        anisotropy = TRUE,
        control = control
      )
    } else {
        #pass same mesh as prior model
        mesh <-  make_mesh(dat, xy_cols = c("X", "Y"), 
                     mesh = readRDS(file = here("meshes/bs_vast_mesh.RDS")))
        fit <- sdmTMB( 
          cpue ~ 0 + year_f,
          spatial_varying = ~ env,
          data = dat, 
          mesh = mesh,
          family = delta_gamma(type = "poisson-link"), 
          time = "year", 
          spatial = "on",
          spatiotemporal = "ar1",
          extra_time = 2020L, 
          silent = FALSE,
          anisotropy = TRUE,
          control = control
        )
    }
    saveRDS(fit, file = here("species_specific_code", "BS", species, "index_comparison", "fit.RDS"))
  } else {
    fit <- readRDS(f1)
}

sanity(fit)
summary(fit)
# diagnose estimation issues due to model structure
#TMBhelper::check_estimability(fit$tmb_obj)
```

We can compare the index we would get using sdmTMB. 

```{r sdmTMB-index, echo=TRUE}
#TODO: Scrap below and instead upload saved prediction grid

# prep prediction grids (all, EBS, NBS) and transform to UTM projection
load(here("extrapolation_grids", "eastern_bering_sea_grid.rda"))
load(here("extrapolation_grids", "northern_bering_sea_grid.rda"))

# EBS grid
grid_ebs <- as.data.frame(eastern_bering_sea_grid)
names(grid_ebs) <- tolower(names(grid_ebs))
add_utm_columns(grid_ebs, ll_names = c("lon", "lat"), units = "km")

# NBS grid
grid_nbs <- as.data.frame(northern_bering_sea_grid)
names(grid_nbs) <- tolower(names(grid_nbs))
add_utm_columns(grid_nbs, ll_names = c("lon", "lat"), units = "km")

# Combined grid
grid <- bind_rows(grid_nbs, grid_ebs)

# replicate extrapolation grids for each year in data
pred_grid_ebs <- replicate_df(grid_ebs, "year_f", unique(dat$year_f))
pred_grid_nbs <- replicate_df(grid_nbs, "year_f", unique(dat$year_f))
pred_grid <- replicate_df(grid, "year_f", unique(dat$year_f))
pred_grid_ebs$year <- as.integer(as.character(factor(pred_grid_ebs$year_f)))
pred_grid_nbs$year <- as.integer(as.character(factor(pred_grid_nbs$year_f)))
pred_grid$year <- as.integer(as.character(factor(pred_grid$year_f)))

# join in environmental covariate (cold pool or mean bottom temperature)
pred_grid_ebs <- left_join(pred_grid_ebs, rename(env_join, cpe = env), by = "year") 
pred_grid_nbs <- left_join(pred_grid_nbs, rename(env_join, cpe = env), by = "year")
pred_grid <- left_join(pred_grid, rename(env_join, cpe = env), by = "year")

# get predictions for total area, and the two subareas of interest (EBS, NBS)
# f2 <- here("species_specific_code", "BS", species,
#            "index_comparison", "predictions.RData")
# if (!file.exists(f2)) {
#   p <- predict(fit, newdata = pred_grid, return_tmb_object = TRUE)
#   p_ebs <- predict(fit, newdata = pred_grid_ebs, return_tmb_object = TRUE)
#   p_nbs <- predict(fit, newdata = pred_grid_nbs, return_tmb_object = TRUE)
#     save(p, p_ebs, p_nbs, file = f2)
# } else {
#   load(f2)
# }

# get indices for total area, and the two subareas of interest (EBS, NBS)
# f3 <- here("species_specific_code", "BS", species, 
#            "index_comparison", "indices.RData")
# if (!file.exists(f3)) {
#   gc()
#   ind <- get_index(p, bias_correct = FALSE, area = pred_grid$area_in_survey_km2)
#   ind$stratum <- "Both"
# 
#   ind_ebs <- get_index(p_ebs, bias_correct = FALSE, area = pred_grid_ebs$area_in_survey_km2)
#   ind_ebs$stratum <- "EBS"
# 
#   ind_nbs <- get_index(p_nbs, bias_correct = FALSE, area = pred_grid_nbs$area_in_survey_km2)
#   ind_nbs$stratum <- "NBS"
#   save(ind, ind_ebs, ind_nbs, file = f3)
# } else {
# load(f3)
# }

# NOTE: if using get_index_split() rather than get_index() you need to pass the 
# model object and new data (not prediction object, you can bypass that step) and run:
f3 <- here("species_specific_code", "BS", species, phase, "index.RDS")
if (!file.exists(f3)) {
  gc()
  if(species == "kamchatka_flounder"){
    ind <- get_index_split(fit, newdata = pred_grid_ebs, nsplit = 2,
                           bias_correct = TRUE, 
                           area = pred_grid_ebs$area_in_survey_km2)
  } else {
      ind <- get_index_split(fit, newdata = pred_grid, nsplit = 2, # may need 6 if have 64GB RAM
                             bias_correct = TRUE, 
                             area = pred_grid$area_in_survey_km2)
  }
  saveRDS(ind, file = here("species_specific_code", "BS", species, phase, "index.RDS"))
} else {
load(f3)
}
```

Now, we can compare the index to the prior model.

```{r index-compare, message=FALSE, warning=FALSE}
#TODO: incorporate design-based estimate like GOA script
  if(species == "kamchatka_flounder"){
    stratum <- "EBS"
  } else {
    stratum <- "Both"
  }

old_i <- read.csv(here("species_specific_code", "BS", species, "index_comparison", "Index.csv")) %>%
  mutate(index = "mb_old", year = as.numeric(Time), est = Estimate, 
    se = Std..Error.for.ln.Estimate.) %>% 
  filter(year != 2020, Stratum == stratum) %>%
  select(index, year, est, se) %>% 
  mutate(lwr = exp(log(est) + qnorm(0.025) * se)) %>% 
  mutate(upr = exp(log(est) + qnorm(0.975) * se))
new_i <- ind %>% mutate(index = "mb_new")
both_i <- bind_rows(new_i, old_i) %>% filter(est > 0)

ggplot(both_i, aes(x = year, y = est, ymin = lwr, ymax = upr, colour = index)) + 
  geom_ribbon(alpha = 0.1) +
  geom_line(alpha = 0.8) + 
  ylim(0, max(both_i$upr)) +
  coord_cartesian(expand = FALSE)
```
