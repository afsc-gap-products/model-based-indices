---
title: "sdmTMB Bering indices"
output:
  bookdown::pdf_document2:
    highlight: pygments
    toc: true
    number_sections: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.asp = 0.618,
  cache = FALSE,
  autodep = TRUE,
  cache.comments = FALSE
)
```

```{r packages, message=FALSE, warning=FALSE, cache=FALSE}
#remotes::install_github("pbs-assess/sdmTMB")
library(sdmTMB)
library(dplyr)
library(ggplot2)
library(here)
# Install coldpool package, if not already installed. Must update each year.
if (!requireNamespace("coldpool", quietly = TRUE)) {
  remotes::install_github("afsc-gap-products/coldpool")
}

phase <- c("hindcast", "production")[2] # specify analysis phase
sp <- 3 # specify species from species vector
species <- c("yellowfin_sole", "pollock", "pacific_cod", "kamchatka_flounder")[sp]

# Set year
this_year <- as.numeric(format(Sys.Date(), "%Y"))
if(phase == "hindcast") {this_year <- this_year - 1}  

```

We will fit geostatistical spatiotemporal models with sdmTMB for the purposes of index standardization. We will use data from the EBS/NBS AFSC GAP bottom trawl surveys. The density units we will work in are either kg/km^2^ or n/km^2^, for biomass or numerical abundance. 

```{r data, echo = TRUE}
if(species == "pacific_cod"){
  dat <- readRDS(here("species_specific_code", "BS", species, phase, 
                        "data", "data_geostat_index.RDS"))
  dat <- rename(dat, cpue = cpue_n_km2)
}
if(species == "pollock"){
  dat <- read.csv(here("species_specific_code", "BS", species, 
                       "data", paste0("VAST_ddc_all_", this_year, ".csv")))  
  dat <- dplyr::transmute(dat,
                          cpue = ddc_cpue_kg_ha * 100, # converts cpue from kg/ha to kg/km^2
                          year = as.integer(year),
                          lat = start_latitude,
                          lon = start_longitude
                          )
}
if(species %in% c("yellowfin_sole", "kamchatka_flounder")){
  dat <- readRDS(here("species_specific_code", "BS", species, phase, 
                      "data", "data_geostat_index.RDS"))  
  dat <- rename(dat, cpue = cpue_kg_km2)
}

dat <- dat[!is.na(dat$cpue),]
```

We also need to pull in the appropriate environmental covariate as this is used as a spatially varying covariate in AFSC GAP Bering Sea indices. For yellowfin sole, this is the mean bottom temperature in waters less than 100m. For other species, this is the cold pool extent. The cold pool is defined here as the areal extent (in km^2^) of seawater equal to or colder than 2 degrees Celsius near the seafloor, calculated from observations from the AFSC GAP EBS/NBS bottom trawl survey. We center and scale this for inclusion as a covariate.

```{r covariate, echo = TRUE}

env_df <- coldpool::cold_pool_index
  
if(species == "yellowfin_sole"){
  env <- cbind(env_df, env = scale(coldpool::cold_pool_index$MEAN_BT_LT100M)) |>
    mutate(year = as.integer(YEAR)) |>
    select(year, env)
} else {
  env <- cbind(env_df, env = scale(coldpool::cold_pool_index$AREA_LTE2_KM2)) |>
    mutate(year = as.integer(YEAR)) |>
    select(year, env)
}

dat <- left_join(dat, env, by = "year") 

# Final data manipulation steps
dat$year_f <- as.factor(dat$year)

dat <- add_utm_columns(dat, ll_names = c("lon", "lat"), utm_crs = 32602, units = "km")
```
Now we fit the model in sdmTMB:

```{r fit, echo = TRUE, results = 'hide'}

# detect if any years have occurrences at every haul and fix params as needed
mins <- dat %>% group_by(year) %>% summarize(min = min(cpue))
if(sum(mins$min) == 0){
  control = sdmTMBcontrol()
} else {
  no_zero_yr <- as.integer(mins %>% filter(min > 0) %>% select(year))
			# set up map and fix value of p(occurrence) to slightly less than 1:
			yrs <- sort(unique(factor(dat$year)))
			.map <- seq_along(yrs)
			.map[yrs %in% no_zero_yr] <- NA
			.map <- factor(.map)
			.start <- rep(0, length(yrs))
			.start[yrs %in% no_zero_yr] <- 20

			control =  sdmTMBcontrol(
            map = list(b_j = .map),
            start = list(b_j = .start)
			    )
}

dir <- here("species_specific_code", "BS", species, phase, "results", "/")
  if (!dir.exists(paths = dir)) dir.create(path = dir, recursive = TRUE)

f1 <- here("species_specific_code", "BS", species, phase, "results", "fit.RDS")
if (!file.exists(f1)) {
  
    if(species == "kamchatka_flounder"){
      #make mesh just for EBS only, need to try out different numbers of knots
        mesh <-  make_mesh(dat, xy_cols = c("X", "Y"), 
                     mesh = readRDS(file = here("meshes/ebs_vast_mesh_250_knots.RDS")))
      #fit to EBS only, using IID spatiotemporal fields instead of "ar1"
      fit <- sdmTMB( 
        cpue ~ 0 + year_f,
        spatial_varying = ~ env,
        data = dat, 
        mesh = mesh,
        family = delta_gamma(type = "poisson-link"), 
        time = "year", 
        spatial = "on",
        spatiotemporal = "iid",
        silent = FALSE,
        anisotropy = TRUE,
        control = control
      )
    } else {
        #pass same mesh as prior model
        mesh <-  make_mesh(dat, xy_cols = c("X", "Y"), 
                     mesh = readRDS(file = here("meshes/bs_vast_mesh_250_knots.RDS")))
        fit <- sdmTMB( 
          cpue ~ 0 + year_f,
          spatial_varying = ~ env,
          data = dat, 
          mesh = mesh,
          family = delta_gamma(type = "poisson-link"), 
          time = "year", 
          spatial = "on",
          spatiotemporal = "ar1",
          extra_time = 2020L, 
          silent = FALSE,
          anisotropy = TRUE,
          control = control
        )
    }
    saveRDS(fit, file = f1)
  } else {
    fit <- readRDS(f1)
}
```

Make predictions and index:

```{r predictions-index, echo=TRUE}
# check fit before proceeding
sanity(fit)
summary(fit)
# diagnose estimation issues due to model structure
#TMBhelper::check_estimability(fit$tmb_obj)

# load prediction grids for ebs, nbs, and both combined
grid_ebs <- read.csv(here("extrapolation_grids", "ebs_coarse_grid.csv"))
grid_nbs <- read.csv(here("extrapolation_grids", "nbs_coarse_grid.csv"))
grid <- read.csv(here("extrapolation_grids", "bering_coarse_grid.csv"))

# replicate prediction grids for each year in data
pred_grid_ebs <- replicate_df(grid_ebs, "year_f", unique(dat$year_f))
pred_grid_nbs <- replicate_df(grid_nbs, "year_f", unique(dat$year_f))
pred_grid <- replicate_df(grid, "year_f", unique(dat$year_f))
pred_grid_ebs$year <- as.integer(as.character(factor(pred_grid_ebs$year_f)))
pred_grid_nbs$year <- as.integer(as.character(factor(pred_grid_nbs$year_f)))
pred_grid$year <- as.integer(as.character(factor(pred_grid$year_f)))

# join in environmental covariate (cold pool or mean bottom temperature)
pred_grid_ebs <- left_join(pred_grid_ebs, env, by = "year") 
pred_grid_nbs <- left_join(pred_grid_nbs, env, by = "year")
pred_grid <- left_join(pred_grid, env, by = "year")

# get predictions
f2 <- here("species_specific_code", "BS", species, phase, "results", "predictions.RData")
if (!file.exists(f2)) {
  if(species == "kamchatka_flounder"){
    p <- predict(fit, newdata = pred_grid_ebs, return_tmb_object = TRUE)
    save(p, file = f2)
  } else {
      p <- predict(fit, newdata = pred_grid, return_tmb_object = TRUE)
      p_ebs <- predict(fit, newdata = pred_grid_ebs, return_tmb_object = TRUE)
      p_nbs <- predict(fit, newdata = pred_grid_nbs, return_tmb_object = TRUE)
      save(p, p_ebs, p_nbs, file = f2)
  }
} else {
  load(f2)
}

# get indices
gc()

f3 <- here("species_specific_code", "BS", species, phase, "results", "indices.RDS")
if (!file.exists(f3)) {
  if(species == "kamchatka_flounder"){
    ind <- get_index(p, bias_correct = TRUE, area = pred_grid_ebs$area_km2)
    ind$region <- "EBS"
    
    save(ind, file = f3)
  } else {
    ind <- get_index(p, bias_correct = TRUE, area = pred_grid$area_km2)
    ind$region <- "Both"
    
    gc()
    ind_ebs <- get_index(p_ebs, bias_correct = TRUE, area = pred_grid_ebs$area_km2)
    ind_ebs$region <- "EBS"
  
    gc()
    ind_nbs <- get_index(p_nbs, bias_correct = TRUE, area = pred_grid_nbs$area_km2)
    ind_nbs$region <- "NBS"
    
    ind_all <- bind_rows(ind, ind_ebs, ind_nbs)
    saveRDS(ind_all, file = f3)
    write.csv(ind_all, here("species_specific_code", "BS", species, phase, 
                            "results", "indices.csv"), row.names = FALSE)
  }
} else {
ind_all <- readRDS(f3)
}
```
Make maps and diagnostics:

```{r plots, echo=TRUE}
## Plot predicted density maps and fit diagnostics ----
# q-q plot
pdf(file = here("species_specific_code", "BS", species, phase, "results", "qq.pdf"),
    width = 5, height = 5)
  sims <- simulate(fit, nsim = 500, type = "mle-mvn") 
  sims |> dharma_residuals(fit, test_uniformity = FALSE)
dev.off()

#residuals on map plot, by year
resids <- sims |>
    dharma_residuals(fit, test_uniformity = FALSE, return_DHARMa = TRUE)
fit$data$resids <- resids$scaledResiduals

ggplot(subset(fit$data, !is.na(resids) & is.finite(resids)), aes(X, Y, col = resids)) +
  scale_colour_gradient2(name = "residuals", midpoint = 0.5) +
  geom_point(size = 0.7) +
  scale_x_continuous(breaks = c(250, 750)) +
  scale_y_continuous(breaks = c(6000, 6500, 7000)) +
  facet_wrap(~year) +
  coord_fixed() +
  theme_bw()
ggsave(file = here("species_specific_code", "BS", species, phase, "results",
                   "residuals_map.pdf"),
       height = 9, width = 6.5, units = c("in"))

# predictions on map plot, by year
if(species == "pacific_cod"){
  title <- bquote('Predicted densities'~(n / km^2))
} else {
  title <- bquote('Predicted densities'~(kg / km^2))
}
ggplot(p$data, aes(X, Y, fill = exp(est1 + est2))) +
  geom_tile(width = 22.224, height = 22.224) +
  scale_fill_viridis_c(trans = "sqrt", name = "", option = "magma", direction = -1) +
  scale_x_continuous(breaks = c(250, 750)) +
  scale_y_continuous(breaks = c(6000, 6500, 7000)) +
  facet_wrap(~year) +
  coord_fixed() +
  ylab("Northings (km)") +
  xlab("Eastings (km)") +
  ggtitle(title) +
  theme_bw()
ggsave(file = here("species_specific_code", "BS", species, phase, "results",
                   "predictions_map.png"),
       height = 7, width = 6.5, units = c("in"))
```

Now, we can compare the index to the prior model.

```{r index-compare, message=FALSE, warning=FALSE, echo = TRUE}
## query db index
# channel <- gapindex::get_connected(check_access = FALSE) # enter credentials 
# 
# species_code <- c("10210", "21740", "21720", "10112")[sp]
#
# if(species == "pacific_cod"){
#   query <- paste0('
#     SELECT 
#     \'db\' AS "index",
#     YEAR AS "year",
#     POPULATION_COUNT AS "est",
#     (POPULATION_COUNT - SQRT(POPULATION_VAR) * (1.959964)) as "lwr", 
#     (POPULATION_COUNT + SQRT(POPULATION_VAR) * (1.959964)) as "upr", 
#     AREA_ID
#     
#     -- Identify what tables to pull data from
#     FROM GAP_PRODUCTS.BIOMASS
#     WHERE AREA_ID IN (99900, 99902)
#     AND SPECIES_CODE = ', species_code)
# } else {
#   query <- paste0('
#     SELECT 
#     \'db\' AS "index",
#     YEAR AS "year",
#     BIOMASS_MT * 1000 AS "est",
#     (BIOMASS_MT - SQRT(BIOMASS_VAR) * (1.959964)) * 1000 as "lwr", 
#     (BIOMASS_MT + SQRT(BIOMASS_VAR) * (1.959964)) * 1000 as "upr", 
#     AREA_ID
#         
#     -- Identify what tables to pull data from
#     FROM GAP_PRODUCTS.BIOMASS
#     WHERE AREA_ID IN (99900, 99902)
#     AND SPECIES_CODE = ', species_code)
# }
# db_i <- RODBC::sqlQuery(channel = channel, query = query)
# db_i <- db_i %>% 
#   mutate(region = recode(AREA_ID, 
#                           `99900` = "EBS", 
#                           `99902` = "NBS")) %>% 
#   mutate(index = "db") %>%
#   select(-AREA_ID)

# automate switch between numbers and biomass on index plots
if(species == "pacific_cod"){
  ylab <- "Abundance (n)"
} else {
  ylab <- "Biomass (kg)"
}

# plot indices and compare to old model (only plot new EBS index for KAMs)
if(species == "kamchatka_flounder"){
  ggplot(ind, aes(x = year, y = est, ymin = lwr, ymax = upr)) + 
    geom_ribbon(alpha = 0.1) +
    geom_line(alpha = 0.8) + 
    ylim(0, max(ind$upr)) +
    ggtitle("EBS") +
    coord_cartesian(expand = FALSE) + 
    ylab(ylab) +
    theme_bw()
  ggsave(file = here("species_specific_code", "BS", species, phase, "results", 
                   "index_comparison.pdf"), 
         height = 4, width = 6, units = c("in"))
  } else {
    new_i <- ind_all %>% mutate(index = "mb_new") %>% 
      select(index, region, year, est, lwr, upr)
    
    load(here("species_specific_code", "BS", species, "hindcast", "results", "indices_250_knots.RData"))
    old_i <-  bind_rows(ind, ind_ebs, ind_nbs) %>% mutate(index = "mb_old") %>% 
      select(index, region, year, est, lwr, upr)
    both_i <- bind_rows(new_i, old_i)
    
    ggplot(filter(both_i, region == "Both"), aes(x = year, y = est, ymin = lwr, 
                                                  ymax = upr, colour = index)) + 
      geom_ribbon(alpha = 0.1) +
      geom_line(alpha = 0.8) + 
      ylim(0, max(both_i$upr)) +
      ggtitle("EBS + NBS") +
      coord_cartesian(expand = FALSE) + 
      ylab(ylab) +
      theme_bw()
    ggsave(file = here("species_specific_code", "BS", species, phase, "results",
                       "index_bridge_both.pdf"), 
           height = 4, width = 6, units = c("in"))
    
    ggplot(filter(both_i, region == "EBS"), aes(x = year, y = est, ymin = lwr, 
                                                  ymax = upr, colour = index)) + 
      geom_ribbon(alpha = 0.1) +
      geom_line(alpha = 0.8) + 
      ylim(0, max(both_i$upr)) +
      ggtitle("EBS") +
      coord_cartesian(expand = FALSE) + 
      ylab(ylab) +
      theme_bw()
    ggsave(file = here("species_specific_code", "BS", species, phase, "results",
                       "index_bridge_ebs.pdf"), 
           height = 4, width = 6, units = c("in"))
    
    ggplot(filter(both_i, region == "NBS"), aes(x = year, y = est, ymin = lwr, 
                                                  ymax = upr, colour = index)) + 
      geom_ribbon(alpha = 0.1) +
      geom_line(alpha = 0.8) + 
      ylim(0, max(both_i$upr)) +
      ggtitle("NBS") +
      coord_cartesian(expand = FALSE) + 
      ylab(ylab) +
      theme_bw()
    ggsave(file = here("species_specific_code", "BS", species, phase, "results",
                       "index_bridge_nbs.pdf"), 
           height = 4, width = 6, units = c("in"))
    
    # plot new index only for all regions
    ggplot(new_i, aes(x = year, y = est, ymin = lwr, ymax = upr, colour = region)) + 
      geom_ribbon(alpha = 0.1) +
      geom_line(alpha = 0.8) + 
      ylim(0, max(new_i$upr)) +
      #ggtitle(species) +
      coord_cartesian(expand = FALSE) + 
      ylab(ylab) +
      theme_bw()
    ggsave(file = here("species_specific_code", "BS", species, phase, "results", "index.pdf"), 
           height = 4, width = 6, units = c("in"))
}

# create ESP products ----
f4 <- here("species_specific_code", "BS", species, phase, "results", "cog.csv")
if (!file.exists(f4)) {
  cog <- get_cog(p, bias_correct = FALSE, 
                 area = p$data$area_km2, format = "wide")
      cog$region <- "Both"
  
  # cog_ebs <- get_cog(p_ebs, bias_correct = FALSE, 
  #              area = p_ebs$data$area_km2, format = "wide")
  #   cog_ebs$region <- "EBS"
  #   
  # cog_nbs <- get_cog(p_nbs, bias_correct = FALSE, 
  #              area = p_nbs$data$area_km2, format = "wide")
  #   cog_nbs$region <- "NBS"
  #     
  # cog_all <- bind_rows(cog, cog_ebs, cog_nbs)
  # write.csv(cog_all, file = f4, row.names = FALSE)
  write.csv(cog, file = f4, row.names = FALSE)
  } else {
    cog <- read.csv(file = f4)
  }

  # plot center of gravity as time series and sparkleplot
  cog_plots <- function(results = cog, dir = saveDir, save_data = TRUE, save_plots = TRUE) {
    cog_new <- rbind(cbind.data.frame(year = cog$year, est = cog$est_x, 
                                      lwr = cog$lwr_x, upr = cog$upr_x, 
                                      se = cog$se_x, unit = "Eastings (km)"),
                   cbind.data.frame(year = cog$year, est = cog$est_y, 
                                    lwr = cog$lwr_y, upr = cog$upr_y, 
                                    se = cog$se_y, unit = "Northings (km)"))
  
  
    ts <- ggplot(cog_new, aes(x = year, y = est)) +
      geom_line() +
      geom_ribbon(aes(ymin = (lwr), ymax = (upr)), alpha = 0.2) +
      xlab("Year") + ylab("") +
      facet_wrap(~ unit, ncol = 1, scales = "free_y") +
      theme_bw()
    
    # Convert to lat/long using akgfmaps package and plot
    cog_latlon <- cbind.data.frame(X = cog$est_x, Y = cog$est_y)
    # CRS information for VAST outputs here: 
    # https://github.com/James-Thorson-NOAA/FishStatsUtils/blob/main/R/project_coordinates.R
    cog_latlon <- akgfmaps::transform_data_frame_crs(cog_latlon, 
                                                     coords = c("X", "Y"), 
                                                     in.crs = "+proj=utm +datum=WGS84 +units=km +zone=2",
                                                     out.crs = "+proj=longlat +datum=WGS84")
    cog_latlon$Year <- cog$year
    
    # Include error in COG estimate before transformation to get min & max values
    cog_min <- cbind.data.frame(X = cog$lwr_x, Y = cog$lwr_y)
    cog_min <- akgfmaps::transform_data_frame_crs(cog_min, 
                                                  coords = c("X", "Y"), 
                                                  in.crs = "+proj=utm +datum=WGS84 +units=km +zone=2",
                                                  out.crs = "+proj=longlat +datum=WGS84")
    
    cog_max <- cbind.data.frame(X = cog$upr_x, Y = cog$upr_y)
    cog_max <- akgfmaps::transform_data_frame_crs(cog_max, 
                                                  coords = c("X", "Y"), 
                                                  in.crs = "+proj=utm +datum=WGS84 +units=km +zone=2",
                                                  out.crs = "+proj=longlat +datum=WGS84")
    cog_error <- cbind.data.frame(cog_latlon, 
                                  xmin = cog_min$X, xmax = cog_max$X,
                                  ymin = cog_min$Y, ymax = cog_max$Y)
    
    # Plot on a map
    world <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf")
    sf::sf_use_s2(FALSE)  # turn off spherical geometry
    map <- ggplot(data = world) +
      geom_sf() +
      geom_point(data = cog_latlon,
                 aes(x = X, y = Y, color = Year), size = 1) +
      # geom_errorbar(data = cog_error,
      #               aes(x = X, y = Y, ymin = ymin,ymax = ymax, color = Year), alpha = 0.8) +
      # geom_errorbarh(data = cog_error,
      #                aes(x = X, y = Y, xmin = xmin,xmax = xmax, color = Year), alpha = 0.8) +
      coord_sf(xlim = c(-179, -157), ylim = c(54, 65), expand = FALSE) +
      viridis::scale_color_viridis(option = "plasma", discrete = FALSE, end = 0.9) +
      scale_x_continuous(breaks = c(-178, -158)) +
      scale_y_continuous(breaks = c(55, 64)) +
      labs(x = NULL, y = NULL) +
      ggsidekick::theme_sleek() +
      theme(plot.background = element_rect(fill = "transparent"))
    
    cog_error2 <- cog_error[-1, c(1:2)]
    cog_error2[nrow(cog_error2) + 1, ] <- NA
    colnames(cog_error2) <- c("X2", "Y2")
    cog_error2 <- cbind.data.frame(cog_error, cog_error2) 
    
    # Plot as scatter (sparkleplot)
    sparkle <- ggplot(data = cog_error, aes(x = X, y = Y, color = Year)) +
      geom_point() +
      # With arrow
      # geom_segment(data = cog_error2 %>% filter(Year >= this_year - 10), 
      #              aes(x = X, y = Y, xend = X2, yend = Y2), 
      #              alpha = 0.8, arrow = arrow(length = unit(0.03, "npc"))) +
      # Without arrow
      geom_segment(data = cog_error2 %>% filter(Year >= this_year - 10), 
                   aes(x = X, y = Y, xend = X2, yend = Y2), 
                   alpha = 0.8) +
      geom_errorbar(aes(ymin = ymin, ymax = ymax, color = Year), alpha = 0.4) +
      geom_errorbarh(aes(xmin = xmin, xmax = xmax, color = Year), alpha = 0.4) +
      viridis::scale_color_viridis(option = "plasma", discrete = FALSE, end = 0.9) +
      xlab("Longitude (°W)") + ylab("Latitude (°N)") +
      ggsidekick::theme_sleek() +
      theme(plot.background = element_rect(fill = "transparent"))
    
    # Inset map into sparkleplot
    inset <- cowplot::ggdraw() +
      cowplot::draw_plot(plot = sparkle) +
      cowplot::draw_plot(plot = map +
                         theme(legend.position = "none") +
                         guides(x = "none", y = "none"), 
                         x = 0.81, y = 0.75, width = 0.21, height = 0.21) 
    
    # Combine sparkleplot and time-series plot
    all <- cowplot::plot_grid(inset, ts)
    
    # Another inset for using independently
    inset2 <- cowplot::ggdraw() +
      cowplot::draw_plot(plot = sparkle) +
      cowplot::draw_plot(plot = map +
                         theme(legend.position = "none") +
                         guides(x = "none", y = "none"), 
                         x = 0.60, y = 0.76, width = 0.21, height = 0.21) 
    
    dir <- here("species_specific_code", "BS", species, phase, "results")
    if(save_data == TRUE) {
      # Save COG as lat/long (without error)
      cog_latlon <- cog_latlon[, c(3, 2, 1)]
      colnames(cog_latlon) <- c("Year", "Latitude", "Longitude")
      write.csv(cog_latlon, file = here(dir, "COG_latlong.csv"), row.names = FALSE)
    }
    
    if(save_plots == TRUE) {
      ggsave(ts, filename = here(dir, "COG_utm.pdf"),
             width = 150, height = 180, unit = "mm")
      ggsave(map, filename = here(dir, "COG_map.pdf"),
             width = 110, height = 90, unit = "mm")
      ggsave(sparkle, filename = here(dir, "COG_scatter.pdf"),
             width = 130, height = 100, unit = "mm")
      ggsave(all, filename = here(dir, "COG_all.pdf"),
             width = 250, height = 100, unit = "mm")
      ggsave(inset2, filename = here(dir, "COG_inset.pdf"),
             width = 130, height = 100, unit = "mm")
    }
    
    return(list(table = cog_latlon, table_error = cog_error, 
                ts = ts, map = map, sparkle = sparkle, all = all, inset = inset2))
  }
  
  cog_out <- cog_plots()
  
f5 <- here("species_specific_code", "BS", species, phase, "results",
           "area_occupied.csv")
if (!file.exists(f5)) {
  eao <- get_eao(p, bias_correct = FALSE, area = p$data$area_km2)
    eao$region <- "Both"
  
  eao_ebs <- get_eao(p_ebs, bias_correct = FALSE, 
               area = p_ebs$data$area_km2)
    eao_ebs$region <- "EBS"
    
  eao_nbs <- get_eao(p_nbs, bias_correct = FALSE, 
               area = p_nbs$data$area_km2)
    eao_nbs$region <- "NBS"
      
  eao_all <- bind_rows(eao, eao_ebs, eao_nbs)
  write.csv(eao_all, file = f5, row.names = FALSE)
  } else {
    eao <- read.csv(file = f5)
  }

  # plot effective area occupied
  eao_plot <- ggplot(eao, aes(x = year, y = est)) +
    geom_line(alpha = 0.8) +
    geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.3) +
    scale_y_continuous(labels = scales::comma, limits = c(0, NA)) +
    ylab(expression(paste("Effective Area Occupied (", km^2, ")"))) +
    theme_bw() +
    facet_wrap(~ region, ncol = 1)
  
  ggsave(file = here("species_specific_code", "BS", species, phase, "results",
                     "area_occupied.pdf"), 
         height = 6, width = 6, units = c("in"))

# Joint variance-covariance matrix for pollock ----
if (species == "pollock") {
  obj <- p$obj  # extract TMB object
  sdrep <- TMB::sdreport(obj)  # get sdreport
  
  # Simulate from joint posterior
  sims_out <- simulate(fit, newdata = pred_grid, nsim = 500, return_tmb_object = FALSE)
  
  sims <- data.frame(sims_out)
  colnames(sims) <- paste0("sim_", seq_len(ncol(sims)))
  
  sims$year <- pred_grid$year
  sims$area_km2 <- pred_grid$area_km2
  
  # Multiply each simulated value by area
  biomass_sims <- sims %>%
    tidyr::pivot_longer(cols = starts_with("sim_"), names_to = "sim", values_to = "density") %>%
    mutate(biomass = density * area_km2) %>%
    group_by(sim, year) %>%
    summarise(total_biomass = sum(biomass), .groups = "drop")
  
  # Pivot to wide: rows = simulations, columns = years
  biomass_wide <- tidyr::pivot_wider(biomass_sims, names_from = year, values_from = total_biomass)
  
  # Compute mean biomass per year
  biomass_means <- colMeans(biomass_wide[,-1])
  
  # Compute variance-covariance matrix
  biomass_cov <- cov(biomass_wide[,-1])
  
  # Standard errors
  biomass_se <- sqrt(diag(biomass_cov))
  
  write.csv(biomass_cov, here("species_specific_code", "BS", species, phase, "results", "biomass_kg_vcov.csv"))
}

```
